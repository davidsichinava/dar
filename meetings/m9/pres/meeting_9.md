<div class="header" style="margin-top:0 px;font-size:60%;">DAR: მეცხრე შეხვედრა</div>

რაოდენობრივ მონაცემთა ანალიზი R-გარემოში
========================================================
author: დავით სიჭინავა
date: 18 მაისი, 2018
autosize: true
transition: none
css: css/style.css
font-family: 'BPG_upper'
<span style="font-weight:bold; font-family:BPG_upper;">მეცხრე შეხვედრა</span>



დღევანდელი შეხვედრის გეგმა
========================================================

- წრფივი რეგრესიის დიაგნოსტირება
- რეგრესია და რანდომიზებული ექსპერიმენტების ანალიზი
- მრავლობითი წრფივი რეგრესია


დაშვება:
========================================================
* წრფივი ურთიერთდამოკიდებულება
* ჰომოსკედასტურობა
* ცდომილებათა დამოუკიდებლობა
* ნორმალური განაწილება


რას ვამოწმებთ:
========================================================
* უკიდურეს წერტილებს
* ,,გავლენიან'' ჩანაწერებს


მაგალითი წინა ლექციიდან: სახის გამომეტყველება და საარჩევნო წარმატება
========================================================

```r
fit <- lm(diff.share ~ d.comp, data = face) # fit the model
fit
```



უკიდურესი წერტილები
========================================================
* outlierTest გვიჩვენებს, თუ მერამდენე ჩანაწერია ყველაზე ,,ექსტემალური'', რომელიც დიდ გავლენას ახდენს მოდელის ხარისხზე



```r
library(car)
outlierTest(fit)
```

გავლენიანი ჩანაწერები
========================================================
* leveragePlots გვიჩვენებს, თუ რომელი ჩანაწერები ,,ექაჩებიან''  მოდელს, რაც იმაზე მიგვითითებს, რომ რეგრესიის წრფე ამ შემთხვევების გავლენით, ოპტიმალურისგან შორს მდებარეობს.


```r
leveragePlots(fit)
```

```r
# კუკის მანძილის დიაგრამები
# D მნიშვნელობის განსაზღვრა > 4/(n-k-1) 
cutoff <- 4/((nrow(face)-length(fit$coefficients)-2))
```
* ამ შემთხვევაში, ჩვენი ამოცანაა, პოტენციური პრობლემის აღმოსაფხვრელად შევისწავლოთ ყველა ის ჩანაწერი, რომელიც cutoff მნიშვნელობას აღემატება.


```r
plot(fit, which=4, cook.levels=cutoff)
```

ცდომილებათა ნორმალურობა
========================================================
* გარდა ზემოთ აღწერილი მეთოდისა, ცდომილებათა ნორმალურობის შესწავლა შესაძლებელია, თუ ნაწინასწარმეტყველებ ცდომილებებს ,,სტიუდენტიზაციას'' გავუკეთებთ, ანუ - მოვახდენთ მის სტანდარტიზაციას სტანდარტული გადახრის მეშვეობით. 


```r
library(MASS)
sresid <- studres(fit) 
hist(sresid, freq=FALSE, 
   main="სტუდენტიზებული ცდომილებების განაწილება")
```

არამუდმივ ცდომილებათა დისპერსია (ჰეტეროსკედასტურობა)
========================================================

```r
### ამ შემთხვევაში, უნდა გამოვიყენოთ lmtest ბიბლიოთეკა და ბრეუშ-პაგანის ტესტი
bptest(fit)
```

* ბრეუშ-პაგანის ტესტის ნულოვანი ჰიპოთეზა არის ის, რომ ცდომილებათად დისპერსია არ არის დამოკიდებული გარე ფაქტორებზე. შესაბამისად, თუ p-მნიშვნელობა მცირეა, ნულოვანი ჰიპოთზა უნდა უარვყოთ და ჩავთვალოთ, რომ ჩვენს მონაცემებს ჰომოსკედასტურობის პრობლემა აქვს.

* თუ მონაცემები ჰეტეროსკედასტურია, შესაბამისად, გამოთვლილი სტანდარტული შეცდომა არასწორია. პრობლემის აღმოსაფხვრელად როგორც წესი, ე.წ. რობასტულ (robust) რეგრესიულ მოდელებს იყენებენ

```

მულტიკოლინეარულობა
========================================================

* მრავალწევრი რეგრესიული მოდელის ერთ-ერთი დაშვება არის ის, რომ დამოუკიდებელ ცვლადებს შორის წრფივი დამოკიდებულება არ უნდა იყოს, ან - მცირე დონეზე. თუმცა ეს პირობა ცხოვრებაში არასდროს სრულდება;

* მულტიკოლინეარულობის აღმოჩენის ყველაზე მარტივი ხერხი ამხსნელ ცვლადებს შორის კორელაციის გამოთვლაა. თუმცა ასევე შესაძლებელია ე.წ. დისპერსიის ინფლაციის მაჩვენებლის გამოთვლაა


```r
vif(fit) # დისპერსიის ინფლაციის ფაქტორი 
sqrt(vif(fit)) > 2 # პრობლემატური შემთხვევები
```

მულტიკოლინეარულობა
========================================================
* როგორ მოვაგვაროთ პრობლემა? საჭიროა, გადავხედოთ მოდელის ამხსნელ ცვლადებს და დავრწმუნდეთ, ერთმანეთთან კორელაციაში მყოფი ცვლადები ერთსა და იმავე ფენომენს ზომავენ. თუ თეორიული თვალსაზრისით ასეა, მაშინ შეგვიძლია, ერთ-ერთი რომელიმე ცვლადი რეგრესიული მოდელიდან ამოვიღოთ 




რეგრესია და რანდომიზებული ექსპერიმენტები:
========================================================

```r
women <- read.csv("women.csv")
mean(women$female[women$reserved == 1])
mean(women$female[women$reserved == 0])
```

საშუალოთა შორის სხვაობა (Difference in means):
========================================================

```r
mean(women$water[women$reserved == 1]) - mean(women$water[women$reserved == 0])
```

საშუალოთა შორის სხვაობა (Difference in means):
========================================================

```r
mean(women$irrigation[women$reserved == 1]) - mean(women$irrigation[women$reserved == 0])
```

ექსპერიმენტული დიზაინის ანალიზისას, საშუალოთა შორის სხვაობა უდრის ექსპერიმენტული ცვლადის ბეტა-კოეფიციენტს:
========================================================

```r
lm(water ~ reserved, data = women)
lm(irrigation ~ reserved, data = women)
```

მრავალწევრი რეგრესია
========================================================

```r
social <- read.csv("social.csv")
levels(social$messages)
```

მრავალწევრი რეგრესია
========================================================

```r
fit <- lm(primary2008 ~ messages, data = social)
fit
```

მრავალწევრი რეგრესია
========================================================

```r
social$Control <- ifelse(social$messages == "Control", 1, 0)
social$Hawthorne <- ifelse(social$messages == "Hawthorne", 1, 0)
social$Neighbors <- ifelse(social$messages == "Neighbors", 1, 0)
lm(primary2008 ~ Control + Hawthorne + Neighbors, data = social)
```

პროგნოზი
========================================================

```r
unique.messages <- data.frame(messages = unique(social$messages))
unique.messages

predict(fit, newdata = unique.messages)
```

პროგნოზი
========================================================

```r
fit.noint <- lm(primary2008 ~ -1 + messages, data = social)
fit.noint
```

ექსპერიმენტის ეფექტი
========================================================

```r
# ექსპერიმენტის საშუალო ეფექტი
coef(fit)["messagesNeighbors"] - coef(fit)["messagesControl"]

# საშუალოთა შორის სხვაობა
mean(social$primary2008[social$messages == "Neighbors"]) - mean(social$primary2008[social$messages == "Control"])
```

შესწორებული დეტერმინაციის კოეფიციენტი
========================================================

```r
fitsummary <- summary(fit)
fitsummary$adj.r.squared
```
